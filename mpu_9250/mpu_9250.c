#include "mpu_9250.h"

#include <time.h>

//FUNCTIONS FOR WRITING/READING FROM REGISTERS (via I2C)

uint8_t mpu_9250_i2c_writes(uint8_t msb_register, uint8_t msb_value, uint8_t lsb_register, uint8_t lsb_value) { 
    //send write call to sensor address
    //send register address to sensor
    //send value to register
    uint8_t msb_uint8_t, lsb_uint8_t;
    msb_uint8_t = i2c_write(msb_register, msb_value);
    lsb_uint8_t = i2c_write(lsb_register, lsb_value);
    return (msb_uint8_t && lsb_uint8_t); //returns whether the write succeeded or failed
}

uint8_t mpu_9250_writeMaskedRegister(uint8_t register_addr, uint8_t mask, uint8_t value) {
    uint8_t masked_value = (mask & value);
    uint8_t regvalue;

	if(!i2c_read(register_addr, &regvalue)) return 0;	//read current reg value; if read failed - error

    regvalue = regvalue & ~mask; 		// Zero Mask bits - clear existing bits
    regvalue = regvalue | masked_value; //Set Mask value  - add new bits
    return i2c_write(register_addr, regvalue);	//write new reg value
}

uint16_t mpu_9250_i2c_reads(uint8_t msb_register, uint8_t lsb_register) {
    uint8_t msb;

	#if(TIMING_MPU==1)
	static struct timespec timer_start={0,0}, timer_end={0,0};
	clock_gettime(CLOCK_MONOTONIC, &timer_start);
	#endif

	i2c_read(msb_register, &msb);

	#if(TIMING_MPU==1)
	clock_gettime(CLOCK_MONOTONIC, &timer_end);
	printf("'i2c_read(msb_register, &msb)' took %.3f ms\n",
	((double)timer_end.tv_sec*1.0e3 + 1.0e-6*timer_end.tv_nsec) -
	((double)timer_start.tv_sec*1.0e3 + 1.0e-6*timer_start.tv_nsec));
	clock_gettime(CLOCK_MONOTONIC, &timer_start);
	#endif

	uint8_t lsb;

	i2c_read(lsb_register, &lsb);

	#if(TIMING_MPU==1)
	clock_gettime(CLOCK_MONOTONIC, &timer_end);
	printf("'i2c_read(msb_register, &lsb)' took %.3f ms\n",
	((double)timer_end.tv_sec*1.0e3 + 1.0e-6*timer_end.tv_nsec) -
	((double)timer_start.tv_sec*1.0e3 + 1.0e-6*timer_start.tv_nsec));
	clock_gettime(CLOCK_MONOTONIC, &timer_start);

	#endif
    return ((((uint16_t)msb) << 8) | lsb);

}

uint8_t mpu_9250_readMaskedRegister(uint8_t register_addr, uint8_t mask) {
    uint8_t data;
    uint8_t return_value;

    /* if read successful, return data & mask */
    if(	i2c_read(register_addr, &data) ){
	return_value = (data & mask);
	printf("readMaskedRegister return_value: %d, data: %d\n", return_value, data);
	return return_value;
    }
    else{
	return 0xFF; //error
    }
}

//INITIALIZATION

/** This function sets both the accelerometer and the gyroscope
 * to their most sensitive settings, namely +/- 2g and +/- 250 degrees/sec
 * and disable data filtering (DLPF)
 *
 * if init is successful, returns 1, else 0
 */
uint8_t init_mpu_9250(void) {
	uint8_t init_ok = 0x01;
	init_ok = init_i2c(MPU_I2C_LOCATION, MPU_I2C_ADDRESS);
    	if(init_ok != 1){
		#if (DEBUG_MPU==1)
		printf("Error initializing i2c communication for MPU 9250\n");
		#endif
		return 0;
	}

	if(!mpu_9250_testConnection()){
		printf("Error while testing connection with MPU 9250\n");
		return 0;
	}

	/* seting gyro and accel measure range */
   	init_ok &= mpu_9250_setFullScaleGyroRange(MPU9250_GYRO_FULL_SCALE_250DPS);
	//printf("OK: %d\n",init_ok);
	init_ok &= mpu_9250_setFullScaleAccelRange(MPU9250_FULL_SCALE_4G);
	//printf("OK: %d\n",init_ok);

	/* disabling gyro DLPF */
	init_ok &= mpu_9250_configGyroDLPF(MPU9250_FCHOICE_DISABLE_DLPF);
	//printf("OK: %d\n",init_ok);
	/* enabling accel DLPF */
	init_ok &= mpu_9250_configAccelDLPF(MPU9250_ACCEL_DLPF_10HZ);
	//printf("OK: %d\n",init_ok);

	return init_ok;
}

/** Get gyroscope output rate divider.
 * The sensor register output is based on the Sample Rate.
 * The Sample Rate is generated by dividing the gyroscope output rate by
 * SMPLRT_DIV:
 *
 * Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)
 *
 * where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or
 * 7), and 1kHz when the DLPF is enabled (see Register 26).
 *
 * Note: The accelerometer output rate is 1kHz. This means that for a Sample
 * Rate greater than 1kHz, the same accelerometer sample may be output to the
 * sensor registers more than once.
 *
 * For a diagram of the gyroscope and accelerometer signal paths, see Section 8
 * of the MPU-6000/MPU-6050 Product Specification document.
 *
 * @return Current sample rate
 * @see MPU9250_SMPLRT_DIV
 */
uint8_t mpu_9250_getRate(void) {
	uint8_t data;
	i2c_read(MPU9250_SMPLRT_DIV, &data);
	return data;
}

/** Set gyroscope sample rate divider.
 * @param rate New sample rate divider
 * @see getRate()
 * @see MPU9250_SMPLRT_DIV
 */
uint8_t mpu_9250_setRate(uint8_t rate) {
    return i2c_write(MPU9250_SMPLRT_DIV, rate);
}

// CONFIG register

/** Get digital low-pass filter configuration.
 * The DLPF_CFG parameter sets the digital low pass filter configuration. It
 * also determines the internal sampling rate used by the device as shown in
 * the table below.
 *
 * Note: The accelerometer output rate is 1kHz. This means that for a Sample
 * Rate greater than 1kHz, the same accelerometer sample may be output to the
 * sensor registers more than once.
 *
 * @see datasheet Register 26 - table
 *
 * @return DLFP configuration
 * @see MPU9250_CONFIG
 * @see MPU9250_DLPF_CFG_MASK
 */
uint8_t mpu_9250_getDLPFMode(void) {
    return mpu_9250_readMaskedRegister(MPU9250_CONFIG, MPU9250_DLPF_CFG_MASK); //MPU9250_CONFIG, MPU9250_CFG_DLPF_CFG_BIT, MPU9250_CFG_DLPF_CFG_LENGTH//clarify/fix register values
}

/** Set digital low-pass filter configuration.
 * @param mode New DLFP configuration setting
 * @see getDLPFBandwidth()
 * @see MPU9250_DLPF_BW_256
 * @see MPU9250_CONFIG
 * @see MPU9250_DLPF_CFG_MASK
 */
uint8_t mpu_9250_setDLPFMode(uint8_t mode) {
    if(mode > 7) {
        return 0;
    }
    return mpu_9250_writeMaskedRegister(MPU9250_CONFIG, MPU9250_DLPF_CFG_MASK, mode); //MPU9250_CONFIG, MPU9250_CFG_DLPF_CFG_BIT, MPU9250_CFG_DLPF_CFG_LENGTH, mode);
}

// GYRO_CONFIG register

/** Get full-scale gyroscope range.
 * The FS_SEL parameter allows setting the full-scale range of the gyro sensors,
 * as described in the table below.
 *
 * <pre>
 * 0 = +/- 250 degrees/sec
 * 1 = +/- 500 degrees/sec
 * 2 = +/- 1000 degrees/sec
 * 3 = +/- 2000 degrees/sec
 * </pre>
 *
 * @return Current full-scale gyroscope range setting
 * @see MPU9250_GYRO_FS_250
 * @see MPU9250_GYRO_CONFIG
 * @see MPU9250_GYRO_FS_SEL_MASK
 */
uint8_t mpu_9250_getFullScaleGyroRange(void) {
	uint8_t data=0, read_ok=0;
	read_ok = i2c_read(MPU9250_GYRO_CONFIG, &data);

	if(read_ok == 0) return 0xff; //error

	data = ((data &  MPU9250_GYRO_FS_SEL_MASK)>>3);
	return data;
}

/** Set full-scale gyroscope range.
 * @param range New full-scale gyroscope range value
 * @see getFullScaleRange()
 * @see MPU9250_GYRO_FS_250
 * @see MPU9250_CONFIG
 * @see MPU9250_GYRO_FS_SEL_MASK
 */
uint8_t mpu_9250_setFullScaleGyroRange(uint8_t range) {
	if(range > 3) return 0;

	uint8_t write_ok=0;
	range = (range<<3);

	write_ok = i2c_write(MPU9250_GYRO_CONFIG, range);
	return write_ok;
}

/** Configure Discrete Low Pass Filtering (DLPF) of Gyro -> see CONFIG register 
 * to disable DLPF set fchoice to MPU9250_FCHOICE_DISABLE_DLPF
 */
uint8_t mpu_9250_configGyroDLPF(uint8_t fchoice) {
	if(fchoice<0x10){
		return mpu_9250_writeMaskedRegister(MPU9250_GYRO_CONFIG, MPU9250_GYRO_FCHOICE_B_MASK, fchoice);
	}
	else return 0;
}

// ACCEL_CONFIG register

/** Get self-test enabled setting for accelerometer X axis.
 * @return Self-test enabled value
 * @see MPU9250_SELF_TEST_X_ACCEL
 */
uint8_t mpu_9250_getAccelXSelfTest(void) {
    uint8_t test_result;
	i2c_read(MPU9250_SELF_TEST_X_ACCEL, &test_result); //MPU9250_ACONFIG_XA_ST_BIT, buffer); //check if ACCEL CONFIG2 is relevant
    return (test_result != 0);
}

/** Get self-test enabled setting for accelerometer X axis.
 * @param enabled Self-test enabled value
 * @see MPU9250_SELF_TEST_X_ACCEL
 */
uint8_t mpu_9250_setAccelXSelfTest(uint8_t enabled) {
    return i2c_write(MPU9250_SELF_TEST_X_ACCEL, enabled); //, MPU9250_ACONFIG_XA_ST_BIT, enabled);//check if ACCEL CONFIG2 is relevant
}

/** Get self-test enabled value for accelerometer Y axis.
 * @return Self-test enabled value
 * @see MPU9250_SELF_TEST_Y_ACCEL
 */
uint8_t mpu_9250_getAccelYSelfTest(void) {
    uint8_t test_result;
	i2c_read(MPU9250_SELF_TEST_Y_ACCEL, &test_result); //, MPU9250_ACONFIG_YA_ST_BIT, buffer);//check if ACCEL CONFIG2 is relevant
    return (test_result != 0);
}

/** Get self-test enabled value for accelerometer Y axis.
 * @param enabled Self-test enabled value
 * @see MPU9250_SELF_TEST_Y_ACCEL
 */
uint8_t mpu_9250_setAccelYSelfTest(uint8_t enabled) {
    return i2c_write(MPU9250_SELF_TEST_Y_ACCEL, enabled); //, MPU9250_ACONFIG_YA_ST_BIT, enabled);//check if ACCEL CONFIG2 is relevant
}

/** Get self-test enabled value for accelerometer Z axis.
 * @return Self-test enabled value
 * @see MPU9250_SELF_TEST_Z_ACCEL
 */
uint8_t mpu_9250_getAccelZSelfTest(void) {
    uint8_t test_result;
	i2c_read(MPU9250_SELF_TEST_Z_ACCEL, &test_result); //, MPU9250_ACONFIG_ZA_ST_BIT, buffer);//check if ACCEL CONFIG2 is relevant
    return (test_result != 0);
}

/** Set self-test enabled value for accelerometer Z axis.
 * @param enabled Self-test enabled value
 * @see MPU9250_SELF_TEST_Z_ACCEL
 */
uint8_t mpu_9250_setAccelZSelfTest(uint8_t enabled) {
    return i2c_write(MPU9250_SELF_TEST_Z_ACCEL, enabled); //MPU9250_RA_ACCEL_CONFIG, MPU9250_ACONFIG_ZA_ST_BIT, enabled);//check if ACCEL CONFIG2 is relevant
}

/** Get full-scale accelerometer range.
 * The FS_SEL parameter allows setting the full-scale range of the accelerometer
 * sensors, as described in the table below.
 *
 * <pre>
 * 0 = +/- 2g
 * 1 = +/- 4g
 * 2 = +/- 8g
 * 3 = +/- 16g
 * </pre>
 *
 * @return Current full-scale accelerometer range setting
 * @see MPU9250_ACCEL_FS_2
 * @see MPU9250_ACCEL_CONFIG
 * @see MPU9250_ACCEL_FS_SEL_MASK
 */
uint8_t mpu_9250_getFullScaleAccelRange(void) {
	uint8_t data=0, read_ok=0;
	read_ok = i2c_read(MPU9250_ACCEL_CONFIG, &data);

	if(read_ok == 0) return 0xff;	//error

	data = ((data &  MPU9250_ACCEL_FS_SEL_MASK)>>3);
	return data;
}

/** Set full-scale accelerometer range.
 * @param range New full-scale accelerometer range setting
 * @see getFullScaleAccelRange()
 */
uint8_t mpu_9250_setFullScaleAccelRange(uint8_t range) {
    if(range > 3){
        return 0;
    } else {
	uint8_t write_ok=0;

	range = (range<<3);
	write_ok = i2c_write(MPU9250_ACCEL_CONFIG, range);
	return write_ok;
    }
}

/** Configure Discrete Low Pass Filtering (DLPF) of Accelerometer -> see ACCEL_CONFIG_2 register
 * to disable DLPF set fchoice to MPU9250_FCHOICE_DISABLE_DLPF
 */
uint8_t mpu_9250_configAccelDLPF(uint8_t fchoice) {
	if(fchoice<0x10){
		return mpu_9250_writeMaskedRegister(MPU9250_ACCEL_CONFIG2, MPU9250_ACCEL_FCHOICE_B_MASK | MPU9250_A_DLPF_CFG_MASK, fchoice);
	}
	else return 0;
}

// USER_CTRL register

/** Reset all sensor registers and signal paths.
 * When set to 1, this bit resets the signal paths for all sensors (gyroscopes,
 * accelerometers, and temperature sensor). This operation will also clear the
 * sensor registers. This bit automatically clears to 0 after the reset has been
 * triggered.
 *
 * When resetting only the signal path (and not the sensor registers), please
 * use Register 104, SIGNAL_PATH_RESET.
 *
 * @see MPU9250_RA_USER_CTRL
 * @see MPU9250_USERCTRL_SIG_COND_RESET_BIT
 */
uint8_t mpu_9250_resetSensors(void) {
    return mpu_9250_writeMaskedRegister(MPU9250_USER_CTRL, MPU9250_SIG_COND_RST_MASK, 0xFF);
}

///** Set X-axis accelerometer standby enabled status.

/** Trigger a full device reset.
 * A small delay of ~50ms may be desirable after triggering a reset.
 * @see MPU9250_RA_PWR_MGMT_1
 * @see MPU9250_PWR1_DEVICE_RESET_BIT
 */
uint8_t mpu_9250_reset(void) {
    return mpu_9250_writeMaskedRegister(MPU9250_PWR_MGMT_1, MPU9250_H_RESET_MASK, 0xFF);
}

/** Get clock source setting.
 * @return Current clock source setting
 * @see MPU9250_PWR_MGMT_1
 * @see MPU9250_CLKSEL_MASK
 */
uint8_t mpu_9250_getClockSource(void) {
    return mpu_9250_readMaskedRegister(MPU9250_PWR_MGMT_1, MPU9250_CLKSEL_MASK);
}

//DEFINE OFFSETS

int16_t mpu_9250_getXGyroOffset(void) {
    uint8_t msb;
	i2c_read(MPU9250_XG_OFFSET_H, &msb);
    uint8_t lsb;
	i2c_read(MPU9250_XG_OFFSET_L, &lsb);
    return ((int16_t)(msb << 8) | lsb);
}

uint8_t mpu_9250_setXGyroOffset(int16_t offset) {
    uint8_t msb_offset = offset >> 8;
    uint8_t lsb_offset = offset & 0x00FF;
    uint8_t msb_check = i2c_write(MPU9250_XG_OFFSET_H, msb_offset);
    uint8_t lsb_check = i2c_write(MPU9250_XG_OFFSET_L, lsb_offset);
    return msb_check & lsb_check;
}

// YG_OFFS_TC register
int16_t mpu_9250_getYGyroOffset(void) {
    uint8_t msb;
	i2c_read(MPU9250_YG_OFFSET_H, &msb);
    uint8_t lsb;
	i2c_read(MPU9250_YG_OFFSET_L, &lsb);
    return ((int16_t)(msb << 8) | lsb);
}

uint8_t mpu_9250_setYGyroOffset(int16_t offset) {
    uint8_t msb_offset = offset >> 8;
    uint8_t lsb_offset = offset & 0x00FF;
    uint8_t msb_check = i2c_write(MPU9250_YG_OFFSET_H, msb_offset);
    uint8_t lsb_check = i2c_write(MPU9250_YG_OFFSET_L, lsb_offset);
    return msb_check & lsb_check;
}

// ZG_OFFS_TC register
int16_t mpu_9250_getZGyroOffset(void) {
    uint8_t msb;
	i2c_read(MPU9250_ZG_OFFSET_H, &msb);
    uint8_t lsb;
	i2c_read(MPU9250_ZG_OFFSET_L, &lsb);
    return ((int16_t)(msb << 8) | lsb);
}

uint8_t mpu_9250_setZGyroOffset(int16_t offset) {
    uint8_t msb_offset = offset >> 8;
    uint8_t lsb_offset = offset & 0x00FF;
    uint8_t msb_check = i2c_write(MPU9250_ZG_OFFSET_H, msb_offset);
    uint8_t lsb_check = i2c_write(MPU9250_ZG_OFFSET_L, lsb_offset);
    return msb_check & lsb_check;
}

// XA_OFFS_* registers
int16_t mpu_9250_getXAccelOffset(void) {
    return mpu_9250_i2c_reads(MPU9250_XA_OFFSET_H, MPU9250_XA_OFFSET_L);
}

uint8_t mpu_9250_setXAccelOffset(int16_t offset) {
    return mpu_9250_i2c_writes(MPU9250_XA_OFFSET_H, offset >> 8, MPU9250_XA_OFFSET_L, offset);
}

// YA_OFFS_* register
int16_t mpu_9250_getYAccelOffset(void) {
    return mpu_9250_i2c_reads(MPU9250_YA_OFFSET_H, MPU9250_YA_OFFSET_L);
}

uint8_t mpu_9250_setYAccelOffset(int16_t offset) {
    return mpu_9250_i2c_writes(MPU9250_YA_OFFSET_H, offset >> 8, MPU9250_YA_OFFSET_L, offset);
}

// ZA_OFFS_* register
int16_t mpu_9250_getZAccelOffset(void) {
    return mpu_9250_i2c_reads(MPU9250_ZA_OFFSET_H, MPU9250_ZA_OFFSET_L);
}

uint8_t mpu_9250_setZAccelOffset(int16_t offset) {
    return mpu_9250_i2c_writes(MPU9250_ZA_OFFSET_H, offset >> 8, MPU9250_ZA_OFFSET_L, offset);
}

//GET DEVICE ID
uint8_t mpu_9250_getDeviceID(void) {
	uint8_t whoami;
    i2c_read(MPU9250_WHO_AM_I, &whoami);
    return whoami;
}

/** Verify the I2C connection.
 * Make sure the device is connected and responds as expected.
 * @return True if connection is valid, false otherwise
 */
uint8_t mpu_9250_testConnection(void) {
    uint16_t device_id = mpu_9250_getDeviceID();
	#if(DEBUG_IMU==1)
	printf("DEVICE ID: 0x%02x\n", device_id);
	#endif
    return (device_id == WHOAMI_DEFAULT_VAL_1) | (device_id == WHOAMI_DEFAULT_VAL_2);
}

/** Get X-axis accelerometer reading.
 * @return X-axis acceleration measurement in 16-bit 2's complement format
 * @see getMotion6()
 * @see MPU9250_ACCEL_XOUT_H
 * @see MPU9250_ACCEL_XOUT_L
 */
int16_t mpu_9250_getAccelerationX(void) {
    return (int16_t) mpu_9250_i2c_reads(MPU9250_ACCEL_XOUT_H, MPU9250_ACCEL_XOUT_L);
}

/** Get Y-axis accelerometer reading.
 * @return Y-axis acceleration measurement in 16-bit 2's complement format
 * @see getMotion6()
 * @see MPU9250_ACCEL_YOUT_H
 * @see MPU9250_ACCEL_YOUT_L
 */
int16_t mpu_9250_getAccelerationY(void) {
    return (int16_t) mpu_9250_i2c_reads(MPU9250_ACCEL_YOUT_H, MPU9250_ACCEL_YOUT_L);
}

/** Get Z-axis accelerometer reading.
 * @return Z-axis acceleration measurement in 16-bit 2's complement format
 * @see getMotion6()
 * @see MPU9250_ACCEL_ZOUT_H
 * @see MPU9250_ACCEL_ZOUT_L
 */
int16_t mpu_9250_getAccelerationZ(void) {
    return (int16_t) mpu_9250_i2c_reads(MPU9250_ACCEL_ZOUT_H, MPU9250_ACCEL_ZOUT_L);
}

/** Get 3-axis accelerometer readings.
 * These registers store the most recent accelerometer measurements.
 * Accelerometer measurements are written to these registers at the Sample Rate
 * as defined in Register 25.
 *
 * The accelerometer measurement registers, along with the temperature
 * measurement registers, gyroscope measurement registers, and external sensor
 * data registers, are composed of two sets of registers: an internal register
 * set and a user-facing read register set.
 *
 * The data within the accelerometer sensors' internal register set is always
 * updated at the Sample Rate. Meanwhile, the user-facing read register set
 * duplicates the internal register set's data values whenever the serial
 * interface is idle. This guarantees that a burst read of sensor registers will
 * read measurements from the same sampling instant. Note that if burst reads
 * are not used, the user is responsible for ensuring a set of single byte reads
 * correspond to a single sampling instant by checking the Data Ready interrupt.
 *
 * Each 16-bit accelerometer measurement has a full scale defined in ACCEL_FS
 * (Register 28). For each full scale setting, the accelerometers' sensitivity
 * per LSB in ACCEL_xOUT is shown in the table below:
 *
 * <pre>
 * AFS_SEL | Full Scale Range | LSB Sensitivity
 * --------+------------------+----------------
 * 0       | +/- 2g           | 8192 LSB/mg
 * 1       | +/- 4g           | 4096 LSB/mg
 * 2       | +/- 8g           | 2048 LSB/mg
 * 3       | +/- 16g          | 1024 LSB/mg
 * </pre>
 *
 * @param x 16-bit signed integer container for X-axis acceleration
 * @param y 16-bit signed integer container for Y-axis acceleration
 * @param z 16-bit signed integer container for Z-axis acceleration
 * @see MPU9250_RA_GYRO_XOUT_H
 */
void mpu_9250_getAcceleration(int16_t* ax, int16_t* ay, int16_t* az) {
    *ax = mpu_9250_getAccelerationX();
    *ay = mpu_9250_getAccelerationY();
    *az = mpu_9250_getAccelerationZ();
}

//Gyroscope functions

void mpu_9250_getGyroTestData(uint8_t *gx, uint8_t *gy, uint8_t *gz) {
        i2c_read(MPU9250_SELF_TEST_X_GYRO, gx); 
        i2c_read(MPU9250_SELF_TEST_Y_GYRO, gy); 
        i2c_read(MPU9250_SELF_TEST_Z_GYRO, gz);
}

/** Get X-axis gyroscope reading.
 * @return X-axis rotation measurement in 16-bit 2's complement format
 * @see getMotion6()
 * @see MPU9250_GYRO_XOUT_H
 * @see MPU9250_GYRO_XOUT_L
 */
int16_t mpu_9250_getRotationX(void) {
    return (int16_t) mpu_9250_i2c_reads(MPU9250_GYRO_XOUT_H, MPU9250_GYRO_XOUT_L); 
}

/** Get Y-axis gyroscope reading.
 * @return Y-axis rotation measurement in 16-bit 2's complement format
 * @see getMotion6()
 * @see MPU9250_GYRO_YOUT_H
 * @see MPU9250_GYRO_YOUT_L
 */
int16_t mpu_9250_getRotationY(void) {
    return (int16_t) mpu_9250_i2c_reads(MPU9250_GYRO_YOUT_H, MPU9250_GYRO_YOUT_L); 
}

/** Get Z-axis gyroscope reading.
 * @return Z-axis rotation measurement in 16-bit 2's complement format
 * @see getMotion6()
 * @see MPU9250_GYRO_ZOUT_H
 * @see MPU9250_GYRO_ZOUT_L
 */
int16_t mpu_9250_getRotationZ(void) {
    return (int16_t) mpu_9250_i2c_reads(MPU9250_GYRO_ZOUT_H, MPU9250_GYRO_ZOUT_L); 
}

// GYRO_*OUT_* registers

/** Get 3-axis gyroscope readings.
 * These gyroscope measurement registers, along with the accelerometer
 * measurement registers, temperature measurement registers, and external sensor
 * data registers, are composed of two sets of registers: an internal register
 * set and a user-facing read register set.
 * The data within the gyroscope sensors' internal register set is always
 * updated at the Sample Rate. Meanwhile, the user-facing read register set
 * duplicates the internal register set's data values whenever the serial
 * interface is idle. This guarantees that a burst read of sensor registers will
 * read measurements from the same sampling instant. Note that if burst reads
 * are not used, the user is responsible for ensuring a set of single byte reads
 * correspond to a single sampling instant by checking the Data Ready interrupt.
 *
 * Each 16-bit gyroscope measurement has a full scale defined in FS_SEL
 * (Register 27). For each full scale setting, the gyroscopes' sensitivity per
 * LSB in GYRO_xOUT is shown in the table below:
 *
 * <pre>
 * FS_SEL | Full Scale Range   | LSB Sensitivity
 * -------+--------------------+----------------
 * 0      | +/- 250 degrees/s  | 131 LSB/deg/s
 * 1      | +/- 500 degrees/s  | 65.5 LSB/deg/s
 * 2      | +/- 1000 degrees/s | 32.8 LSB/deg/s
 * 3      | +/- 2000 degrees/s | 16.4 LSB/deg/s
 * </pre>
 *
 * @param x 16-bit signed integer container for X-axis rotation
 * @param y 16-bit signed integer container for Y-axis rotation
 * @param z 16-bit signed integer container for Z-axis rotation
 * @see getMotion6()
 * @see MPU9250_RA_GYRO_XOUT_H
 * @see MPU9250_RA_GYRO_XOUT_L
 */

void mpu_9250_getRotation(int16_t* gx, int16_t* gy, int16_t* gz) {
    *gx = mpu_9250_getRotationX();
    *gy = mpu_9250_getRotationY();
    *gz = mpu_9250_getRotationZ();
}

void mpu_9250_getMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    	
	#if(TIMING_MPU==1)	
	static struct timespec timer_start={0,0}, timer_end={0,0};
	clock_gettime(CLOCK_MONOTONIC, &timer_start);
	#endif
	
	mpu_9250_getAcceleration(ax, ay, az);
	
	#if(TIMING_MPU==1)
	clock_gettime(CLOCK_MONOTONIC, &timer_end);
	/*printf("'mpu_9250_getAcceleration' took %.3f ms\n",
	((double)timer_end.tv_sec*1.0e3 + 1.0e-6*timer_end.tv_nsec) -
	((double)timer_start.tv_sec*1.0e3 + 1.0e-6*timer_start.tv_nsec));*/
	clock_gettime(CLOCK_MONOTONIC, &timer_start);
	#endif
    
    #if(ENABLE_GYRO==1)
	mpu_9250_getRotation(gx, gy, gz);
	#endif

	#if(TIMING_MPU==1)
	clock_gettime(CLOCK_MONOTONIC, &timer_end);
	/*printf("'mpu_9250_getRotation' took %.3f ms\n",
	((double)timer_end.tv_sec*1.0e3 + 1.0e-6*timer_end.tv_nsec) -
	((double)timer_start.tv_sec*1.0e3 + 1.0e-6*timer_start.tv_nsec));*/
	#endif
}

//Temperature functions

int16_t mpu_9250_getTemperature(void) {
	//get currnet internal temperature reading in 16-bit 2's complement format
	return ((int16_t) mpu_9250_i2c_reads(MPU9250_TEMP_OUT_H, MPU9250_TEMP_OUT_L));
	//WARNING mpu_9250_i2c_reads function currently returns uint16_t instead of int16_t
	//((Temp_out - room_temp_offset)/temp_sensitivity) + 21; //celcius
}



//Functions for data conversion

/** converts accel and gyro data in bits from X,Y,Z axes to arrayfloat values in g
 * gets pointer b_in to struct of type motion_bit and converts data into struct of type motion_float pointed on by f_out
 * returns 1 if convertion is successful, else 0
 */
uint8_t mpu_9250_motion2float(motion_bit *b_in, motion_float *f_out){
	
	if(b_in==NULL || f_out==NULL) return 0;

	uint16_t accel_scale_range;
	float accel_factor;	//factor for coversion from bits to float

	#if(ENABLE_GYRO==1)
	uint16_t gyro_scale_range;
	float gyro_factor;	//factor for coversion from bits to float

	/* get gyro scale range*/
	gyro_scale_range = mpu_9250_getFullScaleGyroRange();
	switch(gyro_scale_range){
		case MPU9250_GYRO_FULL_SCALE_250DPS: gyro_scale_range = 250; break;
		case MPU9250_GYRO_FULL_SCALE_500DPS: gyro_scale_range = 500; break;
		case MPU9250_GYRO_FULL_SCALE_1000DPS: gyro_scale_range = 1000; break;
		case MPU9250_GYRO_FULL_SCALE_2000DPS: gyro_scale_range = 2000; break;
		default: return 0;
	}
	gyro_factor = ((float)gyro_scale_range)/((float)(1<<15));	//16 bit ADC

	f_out->gx = (float)(b_in->gx)*gyro_factor;
	f_out->gy = (float)(b_in->gy)*gyro_factor;
	f_out->gz = (float)(b_in->gz)*gyro_factor;

	//printf("Gyro factor: %.1f\n", 1/gyro_factor);
	#endif

	/* get accel scale ranege */
	accel_scale_range = mpu_9250_getFullScaleAccelRange();
	switch(accel_scale_range){
		case MPU9250_FULL_SCALE_2G: accel_scale_range = 2; break;
		case MPU9250_FULL_SCALE_4G: accel_scale_range = 4; break;
		case MPU9250_FULL_SCALE_8G: accel_scale_range = 8; break;
		case MPU9250_FULL_SCALE_16G: accel_scale_range = 16; break;
		default: return 0;
	}
	accel_factor = ((float)accel_scale_range)/((float)(1<<15));	//16 bit ADC

	//printf("Accel factor: %.1f\n", 1/accel_factor);
	
	f_out->ax = (float)(b_in->ax)*accel_factor;
	f_out->ay = (float)(b_in->ay)*accel_factor;
	f_out->az = (float)(b_in->az)*accel_factor;

	return 1;
}

/* converts temp in bits to float value in Celzius */
float mpu_9250_temperature2float(int16_t temp_bits){
	return (temp_bits/333.87 + 21);		//formula is taken from online forum (adafruit and similar)
}

/** checks if there is a change between sign of motion_float sturucts
 *  returns 1 if there is, else 0
 *
 *  sign change is defined as an absolute difference in angle between them
 *  greater than 90 degrees
 *  - this is calculated using their dot product (if negative, then angle > 90)
 *
 *  it takes into account only two dimentions (X and Y)!
 */
uint8_t motion_different_sign(motion_float f1, motion_float f2){
	float f1dotf2 = f1.ax*f2.ax;
	//float f1dotf2 = f1.ax*f2.ax + f1.ay*f2.ay;
	#if (DEBUG_MPU==1)
	printf("Angle change [f1.f2]: %.4f\n", f1dotf2);
	#endif
	if(f1dotf2 < 0) return 1;
	return 0;
}

/* checks if the motion's accel absolute data is above threshold level
 * returns 1 if above, else 0
 *
 * takes into account only X & Y direction!
 */
uint8_t motion_above_threshold(motion_float data, float threshold_level){
	//float abs = data.ax*data.ax + data.ay*data.ay;
	float abs = -data.ax;
	if(abs < -threshold_level) return 1;
	return 0;
}
